subroutine DPINIT (MRELAS, NVARS, COSTS, BL, BU, IND, PRIMAL, &
     INFO, AMAT, CSC, COSTSC, COLNRM, XLAMDA, ANORM, RHS, RHSNRM, &
     IBASIS, IBB, IMAT, LOPT)
!
!! DPINIT is subsidiary to DSPLP.
!
!***LIBRARY   SLATEC
!***TYPE      DOUBLE PRECISION (SPINIT-S, DPINIT-D)
!***AUTHOR  (UNKNOWN)
!***DESCRIPTION
!
!     THE EDITING REQUIRED TO CONVERT THIS SUBROUTINE FROM SINGLE TO
!     DOUBLE PRECISION INVOLVES THE FOLLOWING CHARACTER STRING CHANGES.
!
!     USE AN EDITING COMMAND (CHANGE) /STRING-1/(TO)STRING-2/.
!     /REAL (12 BLANKS)/DOUBLE PRECISION/,/SCOPY/DCOPY/
!     REVISED 810519-0900
!     REVISED YYMMDD-HHMM
!
!     INITIALIZATION SUBROUTINE FOR DSPLP(*) PACKAGE.
!
!***SEE ALSO  DSPLP
!***ROUTINES CALLED  DASUM, DCOPY, DPNNZR
!***REVISION HISTORY  (YYMMDD)
!   811215  DATE WRITTEN
!   890531  Changed all specific intrinsics to generic.  (WRB)
!   890605  Removed unreferenced labels.  (WRB)
!   891009  Removed unreferenced variable.  (WRB)
!   891214  Prologue converted to Version 4.0 format.  (BAB)
!   900328  Added TYPE section.  (WRB)
!***END PROLOGUE  DPINIT
  DOUBLE PRECISION AIJ,AMAT(*),ANORM,BL(*),BU(*),CMAX, &
   COLNRM(*),COSTS(*),COSTSC,CSC(*),CSUM,ONE,PRIMAL(*), &
   RHS(*),RHSNRM,SCALR,TESTSC,XLAMDA,ZERO
  DOUBLE PRECISION DASUM
  INTEGER IBASIS(*),IBB(*),IMAT(*),IND(*)
  LOGICAL CONTIN,USRBAS,COLSCP,CSTSCP,MINPRB,LOPT(8)
!
!***FIRST EXECUTABLE STATEMENT  DPINIT
  ZERO=0.D0
  ONE=1.D0
  CONTIN=LOPT(1)
  USRBAS=LOPT(2)
  COLSCP=LOPT(5)
  CSTSCP=LOPT(6)
  MINPRB=LOPT(7)
!
!     SCALE DATA. NORMALIZE BOUNDS. FORM COLUMN CHECK SUMS.
  go to 30001
!
!     INITIALIZE ACTIVE BASIS MATRIX.
20002 CONTINUE
  go to 30002
20003 RETURN
!
!     PROCEDURE (SCALE DATA. NORMALIZE BOUNDS. FORM COLUMN CHECK SUMS)
!
!     DO COLUMN SCALING if NOT PROVIDED BY THE USER.
30001 if (.NOT.(.NOT. COLSCP)) go to 20004
  J=1
  N20007=NVARS
  go to 20008
20007 J=J+1
20008 if ((N20007-J) < 0) go to 20009
  CMAX=ZERO
  I=0
20011 call DPNNZR(I,AIJ,IPLACE,AMAT,IMAT,J)
  if (.NOT.(I == 0)) go to 20013
  go to 20012
20013 CONTINUE
  CMAX=MAX(CMAX,ABS(AIJ))
  go to 20011
20012 if (.NOT.(CMAX == ZERO)) go to 20016
  CSC(J)=ONE
  go to 20017
20016 CSC(J)=ONE/CMAX
20017 CONTINUE
  go to 20007
20009 CONTINUE
!
!     FORM CHECK SUMS OF COLUMNS. COMPUTE MATRIX NORM OF SCALED MATRIX.
20004 ANORM = ZERO
  J=1
  N20019=NVARS
  go to 20020
20019 J=J+1
20020 if ((N20019-J) < 0) go to 20021
  PRIMAL(J)=ZERO
  CSUM = ZERO
  I=0
20023 call DPNNZR(I,AIJ,IPLACE,AMAT,IMAT,J)
  if (.NOT.(I <= 0)) go to 20025
  go to 20024
20025 CONTINUE
  PRIMAL(J)=PRIMAL(J)+AIJ
  CSUM = CSUM+ABS(AIJ)
  go to 20023
20024 if (IND(J) == 2) CSC(J)=-CSC(J)
  PRIMAL(J)=PRIMAL(J)*CSC(J)
  COLNRM(J)=ABS(CSC(J)*CSUM)
  ANORM = MAX(ANORM,COLNRM(J))
  go to 20019
!
!     if THE USER HAS NOT PROVIDED COST VECTOR SCALING THEN SCALE IT
!     USING THE MAX. NORM OF THE TRANSFORMED COST VECTOR, if NONZERO.
20021 TESTSC=ZERO
  J=1
  N20028=NVARS
  go to 20029
20028 J=J+1
20029 if ((N20028-J) < 0) go to 20030
  TESTSC=MAX(TESTSC,ABS(CSC(J)*COSTS(J)))
  go to 20028
20030 if (.NOT.(.NOT.CSTSCP)) go to 20032
  if (.NOT.(TESTSC > ZERO)) go to 20035
  COSTSC=ONE/TESTSC
  go to 20036
20035 COSTSC=ONE
20036 CONTINUE
  CONTINUE
20032 XLAMDA=(COSTSC+COSTSC)*TESTSC
  if (XLAMDA == ZERO) XLAMDA=ONE
!
!     if MAXIMIZATION PROBLEM, THEN CHANGE SIGN OF COSTSC AND LAMDA
!     =WEIGHT FOR PENALTY-FEASIBILITY METHOD.
  if (.NOT.(.NOT.MINPRB)) go to 20038
  COSTSC=-COSTSC
20038 go to 20002
!:CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!     PROCEDURE (INITIALIZE RHS(*),IBASIS(*), AND IBB(*))
!
!     INITIALLY SET RIGHT-HAND SIDE VECTOR TO ZERO.
30002 call dinit ( MRELAS,ZERO,RHS,1)
!
!     TRANSLATE RHS ACCORDING TO CLASSIFICATION OF INDEPENDENT VARIABLES
  J=1
  N20041=NVARS
  go to 20042
20041 J=J+1
20042 if ((N20041-J) < 0) go to 20043
  if (.NOT.(IND(J) == 1)) go to 20045
  SCALR=-BL(J)
  go to 20046
20045 if (.NOT.(IND(J) == 2)) go to 10001
  SCALR=-BU(J)
  go to 20046
10001 if (.NOT.(IND(J) == 3)) go to 10002
  SCALR=-BL(J)
  go to 20046
10002 if (.NOT.(IND(J) == 4)) go to 10003
  SCALR=ZERO
10003 CONTINUE
20046 CONTINUE
  if (.NOT.(SCALR /= ZERO)) go to 20048
  I=0
20051 call DPNNZR(I,AIJ,IPLACE,AMAT,IMAT,J)
  if (.NOT.(I <= 0)) go to 20053
  go to 20052
20053 CONTINUE
  RHS(I)=SCALR*AIJ+RHS(I)
  go to 20051
20052 CONTINUE
20048 CONTINUE
  go to 20041
!
!     TRANSLATE RHS ACCORDING TO CLASSIFICATION OF DEPENDENT VARIABLES.
20043 I=NVARS+1
  N20056=NVARS+MRELAS
  go to 20057
20056 I=I+1
20057 if ((N20056-I) < 0) go to 20058
  if (.NOT.(IND(I) == 1)) go to 20060
  SCALR=BL(I)
  go to 20061
20060 if (.NOT.(IND(I) == 2)) go to 10004
  SCALR=BU(I)
  go to 20061
10004 if (.NOT.(IND(I) == 3)) go to 10005
  SCALR=BL(I)
  go to 20061
10005 if (.NOT.(IND(I) == 4)) go to 10006
  SCALR=ZERO
10006 CONTINUE
20061 CONTINUE
  RHS(I-NVARS)=RHS(I-NVARS)+SCALR
  go to 20056
20058 RHSNRM=DASUM(MRELAS,RHS,1)
!
!     if THIS IS NOT A CONTINUATION OR THE USER HAS NOT PROVIDED THE
!     INITIAL BASIS, THEN THE INITIAL BASIS IS COMPRISED OF THE
!     DEPENDENT VARIABLES.
  if (.NOT.(.NOT.(CONTIN .OR. USRBAS))) go to 20063
  J=1
  N20066=MRELAS
  go to 20067
20066 J=J+1
20067 if ((N20066-J) < 0) go to 20068
  IBASIS(J)=NVARS+J
  go to 20066
20068 CONTINUE
!
!     DEFINE THE ARRAY IBB(*)
20063 J=1
  N20070=NVARS+MRELAS
  go to 20071
20070 J=J+1
20071 if ((N20070-J) < 0) go to 20072
  IBB(J)=1
  go to 20070
20072 J=1
  N20074=MRELAS
  go to 20075
20074 J=J+1
20075 if ((N20074-J) < 0) go to 20076
  IBB(IBASIS(J))=-1
  go to 20074
!
!     DEFINE THE REST OF IBASIS(*)
20076 IP=MRELAS
  J=1
  N20078=NVARS+MRELAS
  go to 20079
20078 J=J+1
20079 if ((N20078-J) < 0) go to 20080
  if (.NOT.(IBB(J) > 0)) go to 20082
  IP=IP+1
  IBASIS(IP)=J
20082 go to 20078
20080 go to 20003
end
