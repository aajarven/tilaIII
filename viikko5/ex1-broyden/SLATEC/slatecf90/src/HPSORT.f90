subroutine HPSORT (HX, N, STRBEG, STREND, IPERM, KFLAG, WORK, IER)
!
!! HPSORT returns the permutation vector generated by sorting a ...
!            substring within a character array and, optionally,
!            rearrange the elements of the array.  The array may be
!            sorted in forward or reverse lexicographical order.  A
!            slightly modified quicksort algorithm is used.
!***LIBRARY   SLATEC
!***CATEGORY  N6A1C, N6A2C
!***TYPE      CHARACTER (SPSORT-S, DPSORT-D, IPSORT-I, HPSORT-H)
!***KEYWORDS  PASSIVE SORTING, SINGLETON QUICKSORT, SORT, STRING SORTING
!***AUTHOR  Jones, R. E., (SNLA)
!           Rhoads, G. S., (NBS)
!           Sullivan, F. E., (NBS)
!           Wisniewski, J. A., (SNLA)
!***DESCRIPTION
!
!   HPSORT returns the permutation vector IPERM generated by sorting
!   the substrings beginning with the character STRBEG and ending with
!   the character STREND within the strings in array HX and, optionally,
!   rearranges the strings in HX.   HX may be sorted in increasing or
!   decreasing lexicographical order.  A slightly modified quicksort
!   algorithm is used.
!
!   IPERM is such that HX(IPERM(I)) is the Ith value in the
!   rearrangement of HX.  IPERM may be applied to another array by
!   calling IPPERM, SPPERM, DPPERM or HPPERM.
!
!   An active sort of numerical data is expected to execute somewhat
!   more quickly than a passive sort because there is no need to use
!   indirect references. But for the character data in HPSORT, integers
!   in the IPERM vector are manipulated rather than the strings in HX.
!   Moving integers may be enough faster than moving character strings
!   to more than offset the penalty of indirect referencing.
!
!   Description of Parameters
!      HX - input/output -- array of type character to be sorted.
!           For example, to sort a 80 element array of names,
!           each of length 6, declare HX as character HX(100)*6.
!           If ABS(KFLAG) = 2, then the values in HX will be
!           rearranged on output; otherwise, they are unchanged.
!      N  - input -- number of values in array HX to be sorted.
!      STRBEG - input -- the index of the initial character in
!               the string HX that is to be sorted.
!      STREND - input -- the index of the final character in
!               the string HX that is to be sorted.
!      IPERM - output -- permutation array such that IPERM(I) is the
!              index of the string in the original order of the
!              HX array that is in the Ith location in the sorted
!              order.
!      KFLAG - input -- control parameter:
!            =  2  means return the permutation vector resulting from
!                  sorting HX in lexicographical order and sort HX also.
!            =  1  means return the permutation vector resulting from
!                  sorting HX in lexicographical order and do not sort
!                  HX.
!            = -1  means return the permutation vector resulting from
!                  sorting HX in reverse lexicographical order and do
!                  not sort HX.
!            = -2  means return the permutation vector resulting from
!                  sorting HX in reverse lexicographical order and sort
!                  HX also.
!      WORK - character variable which must have a length specification
!             at least as great as that of HX.
!      IER - output -- error indicator:
!          =  0  if no error,
!          =  1  if N is zero or negative,
!          =  2  if KFLAG is not 2, 1, -1, or -2,
!          =  3  if work array is not long enough,
!          =  4  if string beginning is beyond its end,
!          =  5  if string beginning is out-of-range,
!          =  6  if string end is out-of-range.
!
!     E X A M P L E  O F  U S E
!
!      CHARACTER*2 HX, W
!      INTEGER STRBEG, STREND
!      DIMENSION HX(10), IPERM(10)
!      DATA (HX(I),I=1,10)/ '05','I ',' I','  ','Rs','9R','R9','89',
!     1     ',*','N"'/
!      DATA STRBEG, STREND / 1, 2 /
!      call HPSORT (HX,10,STRBEG,STREND,IPERM,1,W)
!      PRINT 100, (HX(IPERM(I)),I=1,10)
! 100 FORMAT (2X, A2)
!      STOP
!      END
!
!***REFERENCES  R. C. Singleton, Algorithm 347, An efficient algorithm
!                 for sorting with minimal storage, Communications of
!                 the ACM, 12, 3 (1969), pp. 185-187.
!***ROUTINES CALLED  XERMSG
!***REVISION HISTORY  (YYMMDD)
!   761101  DATE WRITTEN
!   761118  Modified by John A. Wisniewski to use the Singleton
!           quicksort algorithm.
!   811001  Modified by Francis Sullivan for string data.
!   850326  Documentation slightly modified by D. Kahaner.
!   870423  Modified by Gregory S. Rhoads for passive sorting with the
!           option for the rearrangement of the original data.
!   890620  Algorithm for rearranging the data vector corrected by R.
!           Boisvert.
!   890622  Prologue upgraded to Version 4.0 style by D. Lozier.
!   920507  Modified by M. McClain to revise prologue text.
!   920818  Declarations section rebuilt and code restructured to use
!           IF-THEN-ELSE-ENDIF.  (SMR, WRB)
!***END PROLOGUE  HPSORT
!     .. Scalar Arguments ..
  INTEGER IER, KFLAG, N, STRBEG, STREND
  CHARACTER * (*) WORK
!     .. Array Arguments ..
  INTEGER IPERM(*)
  CHARACTER * (*) HX(*)
!     .. Local Scalars ..
  REAL R
  INTEGER I, IJ, INDX, INDX0, IR, ISTRT, J, K, KK, L, LM, LMT, M, &
          NN, NN2
!     .. Local Arrays ..
  INTEGER IL(21), IU(21)
!     .. External Subroutines ..
  EXTERNAL XERMSG
!     .. Intrinsic Functions ..
  INTRINSIC ABS, INT, LEN
!***FIRST EXECUTABLE STATEMENT  HPSORT
  IER = 0
  NN = N
  if (NN  <  1) THEN
     IER = 1
     call XERMSG ('SLATEC', 'HPSORT', &
      'The number of values to be sorted, N, is not positive.', &
      IER, 1)
     return
  end if
  KK = ABS(KFLAG)
  if (KK /= 1 .AND. KK /= 2) THEN
     IER = 2
     call XERMSG ('SLATEC', 'HPSORT', &
      'The sort control parameter, KFLAG, is not 2, 1, -1, or -2.', &
      IER, 1)
     return
  end if
!
  if ( LEN(WORK)  <  LEN(HX(1))) THEN
     IER = 3
     call XERMSG ('SLATEC',' HPSORT', &
      'The length of the work variable, WORK, is too short.', &
      IER, 1)
     return
  end if
  if (STRBEG  >  STREND) THEN
     IER = 4
     call XERMSG ('SLATEC', 'HPSORT', &
      'The string beginning, STRBEG, is beyond its end, STREND.', &
      IER, 1)
     return
  end if
  if (STRBEG  <  1 .OR. STRBEG  >  LEN(HX(1))) THEN
     IER = 5
     call XERMSG ('SLATEC', 'HPSORT', &
      'The string beginning, STRBEG, is out-of-range.', &
      IER, 1)
     return
  end if
  if (STREND  <  1 .OR. STREND  >  LEN(HX(1))) THEN
     IER = 6
     call XERMSG ('SLATEC', 'HPSORT', &
      'The string end, STREND, is out-of-range.', &
      IER, 1)
     return
  end if
!
!     Initialize permutation vector
!
  DO 10 I=1,NN
     IPERM(I) = I
   10 CONTINUE
!
!     Return if only one value is to be sorted
!
  if (NN  ==  1) RETURN
!
!     Sort HX only
!
  M = 1
  I = 1
  J = NN
  R = .375E0
!
   20 if (I  ==  J) go to 70
  if (R  <=  0.5898437E0) THEN
     R = R+3.90625E-2
  ELSE
     R = R-0.21875E0
  end if
!
   30 K = I
!
!     Select a central element of the array and save it in location L
!
  IJ = I + INT((J-I)*R)
  LM = IPERM(IJ)
!
!     If first element of array is greater than LM, interchange with LM
!
  if (HX(IPERM(I))(STRBEG:STREND)  >  HX(LM)(STRBEG:STREND)) THEN
     IPERM(IJ) = IPERM(I)
     IPERM(I) = LM
     LM = IPERM(IJ)
  end if
  L = J
!
!     If last element of array is less than LM, interchange with LM
!
  if (HX(IPERM(J))(STRBEG:STREND)  <  HX(LM)(STRBEG:STREND)) THEN
     IPERM(IJ) = IPERM(J)
     IPERM(J) = LM
     LM = IPERM(IJ)
!
!        If first element of array is greater than LM, interchange
!        with LM
!
     if (HX(IPERM(I))(STRBEG:STREND)  >  HX(LM)(STRBEG:STREND)) &
        THEN
           IPERM(IJ) = IPERM(I)
           IPERM(I) = LM
           LM = IPERM(IJ)
     ENDIF
  end if
  go to 50
   40 LMT = IPERM(L)
  IPERM(L) = IPERM(K)
  IPERM(K) = LMT
!
!     Find an element in the second half of the array which is smaller
!     than LM
!
   50 L = L-1
  if (HX(IPERM(L))(STRBEG:STREND)  >  HX(LM)(STRBEG:STREND)) &
      go to 50
!
!     Find an element in the first half of the array which is greater
!     than LM
!
   60 K = K+1
  if (HX(IPERM(K))(STRBEG:STREND)  <  HX(LM)(STRBEG:STREND)) &
     go to 60
!
!     Interchange these elements
!
  if (K  <=  L) go to 40
!
!     Save upper and lower subscripts of the array yet to be sorted
!
  if (L-I  >  J-K) THEN
     IL(M) = I
     IU(M) = L
     I = K
     M = M+1
  ELSE
     IL(M) = K
     IU(M) = J
     J = L
     M = M+1
  end if
  go to 80
!
!     Begin again on another portion of the unsorted array
!
   70 M = M-1
  if (M  ==  0) go to 110
  I = IL(M)
  J = IU(M)
!
   80 if (J-I  >=  1) go to 30
  if (I  ==  1) go to 20
  I = I-1
!
   90 I = I+1
  if (I  ==  J) go to 70
  LM = IPERM(I+1)
  if (HX(IPERM(I))(STRBEG:STREND)  <=  HX(LM)(STRBEG:STREND)) &
     go to 90
  K = I
!
  100 IPERM(K+1) = IPERM(K)
  K = K-1
!
  if (HX(LM)(STRBEG:STREND)  <  HX(IPERM(K))(STRBEG:STREND)) &
      go to 100
  IPERM(K+1) = LM
  go to 90
!
!     Clean up
!
  110 if (KFLAG  <=  -1) THEN
!
!        Alter array to get reverse order, if necessary
!
     NN2 = NN/2
     DO 120 I=1,NN2
       IR = NN-I+1
       LM = IPERM(I)
       IPERM(I) = IPERM(IR)
       IPERM(IR) = LM
  120    CONTINUE
  end if
!
!     Rearrange the values of HX if desired
!
  if (KK  ==  2) THEN
!
!        Use the IPERM vector as a flag.
!        If IPERM(I) < 0, then the I-th value is in correct location
!
     DO 140 ISTRT=1,NN
        if (IPERM(ISTRT)  >=  0) THEN
           INDX = ISTRT
           INDX0 = INDX
           WORK = HX(ISTRT)
  130          if (IPERM(INDX)  >  0) THEN
              HX(INDX) = HX(IPERM(INDX))
              INDX0 = INDX
              IPERM(INDX) = -IPERM(INDX)
              INDX = ABS(IPERM(INDX))
              go to 130
           ENDIF
           HX(INDX0) = WORK
        ENDIF
  140    CONTINUE
!
!        Revert the signs of the IPERM values
!
     DO 150 I=1,NN
        IPERM(I) = -IPERM(I)
  150    CONTINUE
!
  end if
!
  return
end
