subroutine PNNZRS (I, XVAL, IPLACE, SX, IX, IRCX)
!
!! PNNZRS is subsidiary to SPLP.
!
!***LIBRARY   SLATEC
!***TYPE      SINGLE PRECISION (PNNZRS-S, DPNNZR-D)
!***AUTHOR  Hanson, R. J., (SNLA)
!           Wisniewski, J. A., (SNLA)
!***DESCRIPTION
!
!     PNNZRS LIMITS THE TYPE OF STORAGE TO A SEQUENTIAL SCHEME.
!     SPARSE MATRIX NON ZERO RETRIEVAL SUBROUTINE.
!
!     SUBROUTINE PNNZRS() GETS THE NEXT NONZERO VALUE IN ROW OR COLUMN
!     +/- IRCX WITH AN INDEX GREATER THAN THE VALUE OF I.
!
!             I ABSOLUTE VALUE OF THIS SUBSCRIPT IS TO BE EXCEEDED
!               IN THE SEARCH FOR THE NEXT NONZERO VALUE. A NEGATIVE
!               OR ZERO VALUE OF I CAUSES THE SEARCH TO START AT
!               THE BEGINNING OF THE VECTOR.  A POSITIVE VALUE
!               OF I CAUSES THE SEARCH TO CONTINUE FROM THE LAST PLACE
!               ACCESSED. ON OUTPUT, THE ARGUMENT I
!               CONTAINS THE VALUE OF THE SUBSCRIPT FOUND.  AN OUTPUT
!               VALUE OF I EQUAL TO ZERO INDICATES THAT ALL COMPONENTS
!               WITH AN INDEX GREATER THAN THE INPUT VALUE OF I ARE
!               ZERO.
!          XVAL VALUE OF THE NONZERO ELEMENT FOUND.  ON OUTPUT,
!               XVAL=0. WHENEVER I=0.
!     IPLACE POINTER INFORMATION WHICH IS MAINTAINED BY THE PACKAGE.
!   SX(*),IX(*) THE WORK ARRAYS WHICH ARE USED TO STORE THE SPARSE
!               MATRIX.  THESE ARRAY CONTENTS ARE AUTOMATICALLY
!               MAINTAINED BY THE PACKAGE FOR THE USER.
!          IRCX POINTS TO THE VECTOR OF THE MATRIX BEING SCANNED.  A
!               NEGATIVE VALUE OF IRCX INDICATES THAT ROW -IRCX IS TO BE
!               SCANNED.  A POSITIVE VALUE OF IRCX INDICATES THAT
!               COLUMN IRCX IS TO BE SCANNED.  A ZERO VALUE OF IRCX IS
!               AN ERROR.
!
!     THIS SUBROUTINE IS A MODIFICATION OF THE SUBROUTINE LNNZRS,
!     SANDIA LABS. REPT. SAND78-0785.
!     MODIFICATIONS BY K.L. HIEBERT AND R.J. HANSON
!     REVISED 811130-1000
!     REVISED YYMMDD-HHMM
!
!***SEE ALSO  SPLP
!***ROUTINES CALLED  IPLOC, XERMSG
!***REVISION HISTORY  (YYMMDD)
!   811215  DATE WRITTEN
!   890531  Changed all specific intrinsics to generic.  (WRB)
!   890605  Removed unreferenced labels.  (WRB)
!   891214  Prologue converted to Version 4.0 format.  (BAB)
!   900315  CALLs to XERROR changed to CALLs to XERMSG.  (THJ)
!   900328  Added TYPE section.  (WRB)
!   910403  Updated AUTHOR and DESCRIPTION sections.  (WRB)
!***END PROLOGUE  PNNZRS
  DIMENSION IX(*)
  REAL XVAL,SX(*),ZERO
  SAVE ZERO
  DATA ZERO /0.E0/
!***FIRST EXECUTABLE STATEMENT  PNNZRS
  IOPT=1
!
!     CHECK VALIDITY OF ROW/COL. INDEX.
!
  if (.NOT.(IRCX  == 0)) go to 20002
  NERR=55
  call XERMSG ('SLATEC', 'PNNZRS', 'IRCX=0.', NERR, IOPT)
!
!     LMX IS THE LENGTH OF THE IN-MEMORY STORAGE AREA.
!
20002 LMX = IX(1)
  if (.NOT.(IRCX < 0)) go to 20005
!
!     CHECK SUBSCRIPTS OF THE ROW. THE ROW NUMBER MUST BE  <=  M AND
!     THE INDEX MUST BE  <=  N.
!
  if (.NOT.(IX(2) < -IRCX .OR. IX(3) < ABS(I))) go to 20008
  NERR=55
  call XERMSG ('SLATEC', 'PNNZRS', &
     'SUBSCRIPTS FOR ARRAY ELEMENT TO BE ACCESSED WERE OUT OF ' // &
     'BOUNDS.', NERR, IOPT)
20008 L=IX(3)
  go to 20006
!
!     CHECK SUBSCRIPTS OF THE COLUMN. THE COL. NUMBER MUST BE  <=  N AND
!     THE INDEX MUST BE  <=  M.
!
20005 if (.NOT.(IRCX > IX(3) .OR. ABS(I) > IX(2))) go to 20011
  NERR=55
  call XERMSG ('SLATEC', 'PNNZRS', &
     'SUBSCRIPTS FOR ARRAY ELEMENT TO BE ACCESSED WERE OUT OF ' // &
     'BOUNDS.', NERR, IOPT)
20011 L=IX(2)
!
!     HERE L IS THE LARGEST POSSIBLE SUBSCRIPT WITHIN THE VECTOR.
!
20006 J=ABS(IRCX)
  LL=IX(3)+4
  LPG = LMX - LL
  if (.NOT.(IRCX > 0)) go to 20014
!
!     SEARCHING FOR THE NEXT NONZERO IN A COLUMN.
!
!     INITIALIZE STARTING LOCATIONS..
  if (.NOT.(I <= 0)) go to 20017
  if (.NOT.(J == 1)) go to 20020
  IPLACE=LL+1
  go to 20021
20020 IPLACE=IX(J+3)+1
20021 CONTINUE
!
!     THE CASE I <= 0 SIGNALS THAT THE SCAN FOR THE ENTRY
!     IS TO BEGIN AT THE START OF THE VECTOR.
!
20017 I = ABS(I)
  if (.NOT.(J == 1)) go to 20023
  ISTART = LL+1
  go to 20024
20023 ISTART=IX(J+3)+1
20024 IEND = IX(J+4)
!
!     VALIDATE IPLACE. SET TO START OF VECTOR if OUT OF RANGE.
!
  if (.NOT.(ISTART > IPLACE .OR. IPLACE > IEND)) go to 20026
  if (.NOT.(J == 1)) go to 20029
  IPLACE=LL+1
  go to 20030
20029 IPLACE=IX(J+3)+1
20030 CONTINUE
!
!     SCAN THROUGH SEVERAL PAGES, if NECESSARY, TO FIND MATRIX ENTRY.
!
20026 IPL = IPLOC(IPLACE,SX,IX)
!
!     FIX UP IPLACE AND IPL if THEY POINT TO PAGING DATA.
!     THIS IS NECESSARY BECAUSE THERE IS CONTROL INFORMATION AT THE
!     END OF EACH PAGE.
!
  IDIFF = LMX - IPL
  if (.NOT.(IDIFF <= 1.AND.IX(LMX-1) > 0)) go to 20032
!
!     UPDATE THE RELATIVE ADDRESS IN A NEW PAGE.
!
  IPLACE = IPLACE + IDIFF + 1
  IPL = IPLOC(IPLACE,SX,IX)
20032 NP = ABS(IX(LMX-1))
  go to 20036
20035 if (ILAST == IEND) go to 20037
20036 ILAST = MIN(IEND,NP*LPG+LL-2)
!
!     THE VIRTUAL END OF THE DATA FOR THIS PAGE IS ILAST.
!
  IL = IPLOC(ILAST,SX,IX)
  IL = MIN(IL,LMX-2)
!
!     THE RELATIVE END OF DATA FOR THIS PAGE IS IL.
!     SEARCH FOR A NONZERO VALUE WITH AN INDEX  >  I ON THE PRESENT
!     PAGE.
!
20038 if (.NOT.(.NOT.(IPL >= IL.OR.(IX(IPL) > I.AND.SX(IPL) /= ZERO)))) &
   go to 20039
  IPL=IPL+1
  go to 20038
!
!     TEST if WE HAVE FOUND THE NEXT NONZERO.
!
20039 if (.NOT.(IX(IPL) > I .AND. SX(IPL) /= ZERO .AND. IPL <= IL)) GO &
  TO 20040
  I = IX(IPL)
  XVAL = SX(IPL)
  IPLACE = (NP-1)*LPG + IPL
  return
!
!     UPDATE TO SCAN THE NEXT PAGE.
20040 IPL = LL + 1
  NP = NP + 1
  go to 20035
!
!     NO DATA WAS FOUND. END OF VECTOR ENCOUNTERED.
!
20037 I = 0
  XVAL = ZERO
  IL = IL + 1
  if ( IL == LMX-1) IL = IL + 2
!
!     if A NEW ITEM WOULD BE INSERTED, IPLACE POINTS TO THE PLACE
!     TO PUT IT.
!
  IPLACE = (NP-1)*LPG + IL
  return
!
!     SEARCH A ROW FOR THE NEXT NONZERO.
!     FIND ELEMENT J=ABS(IRCX) IN ROWS ABS(I)+1,...,L.
!
20014 I=ABS(I)
!
!     CHECK FOR END OF VECTOR.
!
  if (.NOT.(I == L)) go to 20043
  I=0
  XVAL=ZERO
  return
20043 I1 = I+1
  II=I1
  N20046=L
  go to 20047
20046 II=II+1
20047 if ((N20046-II) < 0) go to 20048
!
!     INITIALIZE IPPLOC FOR ORTHOGONAL SCAN.
!     LOOK FOR J AS A SUBSCRIPT IN ROWS II, II=I+1,...,L.
!
  if (.NOT.(II == 1)) go to 20050
  IPPLOC = LL + 1
  go to 20051
20050 IPPLOC = IX(II+3) + 1
20051 IEND = IX(II+4)
!
!     SCAN THROUGH SEVERAL PAGES, if NECESSARY, TO FIND MATRIX ENTRY.
!
  IPL = IPLOC(IPPLOC,SX,IX)
!
!     FIX UP IPPLOC AND IPL TO POINT TO MATRIX DATA.
!
  IDIFF = LMX - IPL
  if (.NOT.(IDIFF <= 1.AND.IX(LMX-1) > 0)) go to 20053
  IPPLOC = IPPLOC + IDIFF + 1
  IPL = IPLOC(IPPLOC,SX,IX)
20053 NP = ABS(IX(LMX-1))
  go to 20057
20056 if (ILAST == IEND) go to 20058
20057 ILAST = MIN(IEND,NP*LPG+LL-2)
  IL = IPLOC(ILAST,SX,IX)
  IL = MIN(IL,LMX-2)
20059 if (.NOT.(.NOT.(IPL >= IL .OR. IX(IPL) >= J))) go to 20060
  IPL=IPL+1
  go to 20059
!
!     TEST if WE HAVE FOUND THE NEXT NONZERO.
!
20060 if (.NOT.(IX(IPL) == J .AND. SX(IPL) /= ZERO .AND. IPL <= IL)) GO &
  TO 20061
  I = II
  XVAL = SX(IPL)
  return
20061 if ( IX(IPL) >= J) ILAST = IEND
  IPL = LL + 1
  NP = NP + 1
  go to 20056
20058 go to 20046
!
!     ORTHOGONAL SCAN FAILED. THE VALUE J WAS NOT A SUBSCRIPT
!     IN ANY ROW.
!
20048 I=0
  XVAL=ZERO
  return
end
